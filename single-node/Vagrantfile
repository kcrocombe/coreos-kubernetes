# -*- mode: ruby -*-
# # vi: set ft=ruby :

require 'fileutils'
require 'open-uri'
require 'tempfile'
require 'yaml'

Vagrant.require_version ">= 1.6.0"

# KJC : Make sure the vagrant-ignition plugin is installed

required_plugins = %w(vagrant-ignition)

plugins_to_install = required_plugins.select { |plugin| not Vagrant.has_plugin? plugin }
if not plugins_to_install.empty?
  puts "Installing plugins: #{plugins_to_install.join(' ')}"
  if system "vagrant plugin install #{plugins_to_install.join(' ')}"
    exec "vagrant #{ARGV.join(' ')}"
  else
    abort "Installation of one or more plugins has failed. Aborting."
  end
end


$update_channel = "stable"
#$update_channel = "beta"
#$update_channel = "alpha"

CLUSTER_IP="10.3.0.1"
NODE_IP = "172.17.4.99"
#NODE_VCPUS = 1
NODE_VCPUS = 4
#NODE_MEMORY_SIZE = 2048
NODE_MEMORY_SIZE = 3072
#NODE_MEMORY_SIZE = 4096


#These are the CT scriprs and Ignition Files that will be injected into our provisioned server
#
HOME = File.dirname(__FILE__)
IGNITION_DRIVE_ROOT = File.join(HOME,".IgnitionVirtualDisks")

SSL_DIR=File.join(HOME,"ssl")

if ! File.exist?(IGNITION_DRIVE_ROOT)
   FileUtils.mkdir_p IGNITION_DRIVE_ROOT
end

CT_SINGLE_NODE_PATH= File.join(HOME, "singleNode.ct")
IGNITION_SINGLE_NODE_PATH= File.join(IGNITION_DRIVE_ROOT, "singleNode.ign")


system("mkdir -p ssl && ./../lib/init-ssl-ca ssl") or abort ("failed generating SSL CA artifacts")
system("./../lib/init-ssl ssl apiserver controller IP.1=#{NODE_IP},IP.2=#{CLUSTER_IP}") or abort ("failed generating SSL certificate artifacts")
system("./../lib/init-ssl ssl admin kube-admin") or abort("failed generating admin SSL artifacts")

Vagrant.configure("2") do |config|
  # always use Vagrant's insecure key
  config.ssh.insert_key = false

  config.vm.box = "coreos-%s" % $update_channel
  config.vm.box_version = ">= 1151.0.0"
  config.vm.box_url = "http://%s.release.core-os.net/amd64-usr/current/coreos_production_vagrant.json" % $update_channel

  config.vm.provider :virtualbox do |v|
    v.cpus = NODE_VCPUS
    v.gui = false
    v.memory = NODE_MEMORY_SIZE

    # On VirtualBox, we don't have guest additions or a functional vboxsf
    # in CoreOS, so tell Vagrant that so it can be smarter.
    v.check_guest_additions = false
    v.functional_vboxsf     = false

  	 # plugin conflict
  	 if Vagrant.has_plugin?("vagrant-vbguest") then
    	config.vbguest.auto_update = false
  	 end


  	 config.vm.network :private_network, ip: NODE_IP
  	 #config.vm.network :public_network, ip: NODE_IP

	 # KJC - following was added to the gitHub cloned version in order that the 'core' user be injected by ignition
	 # at node creattion time.
	 #
	 # enable ignition (this is always done on virtualbox as this is how the ssh key is added to the system)

	 # Compile the yaml based .ct file to json based Ignition Configuration File
    #
    system("ct -in-file=#{CT_SINGLE_NODE_PATH} -out-file=#{IGNITION_SINGLE_NODE_PATH} -platform vagrant-virtualbox -pretty -strict --files-dir .") or abort ("Failed generating singleNode Ignition files.")

    config.ignition.enabled = true
	 config.ignition.config_obj = v
	 config.ignition.ip = NODE_IP
	 config.ignition.hostname = config.vm.hostname
	 config.ignition.drive_root = IGNITION_DRIVE_ROOT
	 config.ignition.drive_name = "configDsk"

    # when the ignition config doesn't exist, the plugin automatically generates a very basic Ignition with the ssh key
    # and previously specified options (ip and hostname). Otherwise, it appends those to the provided config.ign below
	 #
    if File.exist?(IGNITION_SINGLE_NODE_PATH)
    	config.ignition.path = IGNITION_SINGLE_NODE_PATH
	 end
  end
end
